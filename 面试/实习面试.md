#### 账号 1 ：coppsstairrc@hotmail.com

#### 密码 ：Ap1122113

####  不要自己手动输，复制粘贴注意不要复制到空格 账号 2：aabb@lply.cc

#### 密码 ：Ap112211

不要自己手动输，复制粘贴注意不要复制到空格Ssa

#### 账号 3：114455@lply.cc

#### 密码 ：Ap1122113

#### 不要自己手动输，复制粘贴注意不要复制到空格 账号4：1212b@lply.cc

#### 密码 ：Ap11221132（被风控了，联系苹果处理中，预计明天晚上）

# 设计模式

![image-20240326203007939](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240326203007939.png)



# 系统

# c++

1. **cpp哪些容器是线程安全的**？

   ① 多线程对容器的读取写入操作不安全，存在脏数据

* c++中的容器本身并没有提供线程安全的机制

* 但是在c++11中引入了，mutex、lock_guard、shared_mutex等线程安全的容器，可以用来确保对容器的安全访问

  ② 迭代器失效

* 当前位置insert元素后，位置之后的迭代器失效

  ```cpp
  it = vec.insert(it, 3);
  ```

  

* 当前位置erase后，位置之后的迭代器失效

  ```cpp
  iter = cont.erase(iter); 
  ```

  

* 重新开辟内存后，所有底层迭代器失效

```cpp
创建时reserve()足够的空间
```

对于序列容器和链式容器，可以erase后返回新的迭代器iter，对于关联式容器，map\set等，因为没有返回值，所以需要手动迭代器递增，unordered_map可以返回更新迭代器

```cpp
map.erase(iter++);
```

-----------

2. **map的底层原理**

   map是一种关联性容器，他存储键值对，且每个键唯一，他底层采用的数据结构是红黑树，红黑树是一种自平衡的二叉搜索树，他能保证插入、删除、查找的操作中提供long n的时间复杂度

   --------------

   

3. **红黑树的优势，如何实现，哪些地方用到了**

   map、mutimap、set、mutiset底层使用红黑树

   红黑树的特性： 1 根节点为黑

   ​							2 某一结点为红，则其子节点一定为黑，没有连续的两个红节点

   ​							3 任意节点的简单路径上，黑色节点的数目相同，红黑树的最长路径不超过最短路							径的两倍

   红黑树的插入：

   1 若插入根节点，则为黑色

   2 插入非根节点，为红色，，根据叔叔的颜色进行调整

   ​			①叔叔 和 父亲 为红色，则叔叔和父亲均变黑，爷变红，继续调整爷爷

   ​			② 父亲为红，叔叔为黑或空，根据情况进行双旋转 + 变色

-------------------



2. **哈希冲突**

哈希表是一种常见的数据结构，他将输入的关键字映射到一块固定大小的数组中，来实现高效的存储和查找，但是，有时候不同的关键字会映射到同一块数组地址中，造成哈希冲突

开放定址法：顺序的查找下一个空闲的位置

链表发：数组中的各个元素称为头节点，对应的值会以链表的形式插入进去，当插入的形式过多，会插入为红黑树

二次哈希：当一个哈希函数冲突时，在使用另一个函数计算

--------



2. **vector什么时候扩充？扩充机制**

   1. vector是一个可动态增长的数组，插入、reserve、resize等操作都会面临增容问题
   2. 最常见的情况是，vs下capacity是按1.5倍增长的，g++是按2倍增长的。但是具体增长多少，是按照需求定义的，比如我之前阅读过facebook内部使用的fbvecor，他的容量增加策略是：

   * 初始化的时候给8个字节，若装不下一个类型，就给他分配一个类型的空间大小

   * 增长策略是：当现有容量小于或者大于一个临界值时，按照二倍增长
   * 介于给定值中间时候，按照1.5倍增加，并额外给出0.5个空间作为缓冲区

   3. 除此之外，扩容的过程中也会有很多问题，比如说

   * 迭代器失效，我们需要在扩容操作后，返回更新后的迭代器
   * 浅拷贝问题，在开辟新空间后赋值值，若采用内存处理函数memcpy进行拷贝，若vector存储有指针类型，则会导致浅拷贝，因此我们采用元素赋值的方法，调用元素的operator=进行深拷贝

3. **多态原理**

   多态分为两种

   * 编译期间的多态，有函数重载、模板等，==函数重载==的原理是：c++在编译期间根据函数名修饰规则，即根据函数名和参数生成对应的名字放于符号表内
   * 执行期间的多态，即面向对象的特性之一，同一对象的不同行为有多种状态，
   * 多态是==通过虚函数表==实现的，虚函数表内存放的是虚函数的地址，虚基类先生成一张虚函数表，将其拷贝到子类的虚函数表中，表中是基类的虚函数地址，子类重写了虚函数后，将表中的虚函数地址更换
   * 构成多态的==条件==有两个：1 基类通过virtual定义虚函数同一接口，派生类对其实现重写  2 通过基类指针引用调用重写的函数
   * 多态跟实例化对象有关，与调用对象无关
   * 判断是否可以为虚函数？

   | 函数类       | 原理                                      |
   | ------------ | ----------------------------------------- |
   | inline函数   | ❌inline函数没有地址，无法放入虚函数表中   |
   | 静态成员函数 | ❌没有this指针，无法访问到虚基表指针，     |
   | 构造函数     | ❌虚基表是在构造函数的初始化列表开始初始化 |
   | 析构函数     | 基类的析构函数设置为虚函数                |
   |              |                                           |

4. **析构函数为什么设置为虚函数？**

   多态跟实例化的对象有关，与调用的对象无关，当父类指针指向子类对象时,**如果析构函数不是虚函数**,析构就只会释放父类对象,造成内存泄漏。(因为析构重名,只能调用一个,调用默认的父类析构函数)。 **定义成虚函数后**,调用析构时就会取出虚表指针找到实际应该调用的函数。

5. **访问虚函数快还是普通函数快？**

   普通对象：一样快

   传入指针或引用：普通快，因为编译时直接生成地址，虚函数执行时候才生成地址，并且去虚函数表寻找

   ---------

   

6. **组合大于继承**

​	

6. **容器底层**

| 容器   | 底层                                     | sizeof() |
| ------ | ---------------------------------------- | -------- |
| vector | 三个指针 start 、finish 、end_of_storage | 3 * 4    |



## 系统

1. **死锁的四个必要条件？**

​	① 互斥条件：1个资源每次只能被一个进程执行

​	② 请求与保持：一个进程因为等待资源而阻塞的时候，并不会释放已有的资源

​	③ 不可剥夺条件：一个进程没有执行完毕的时候，不能强行剥夺条件

​	④ 循环等待： 若干进程形成了首尾相连的等待资源关系

死锁原因： 资源缺乏、进程顺序安排不合理等

2. **如何避免以及解决项目的死锁？**

   * 预防死锁： ①预先分配资源： 若进程有一个资源不满足，则不分配任何资源

     ​					② 有序分配资源：进程按照指定顺序获取资源

   * 避免死锁： 银行家算法

     如果存在一种进程执行顺序，按照此顺序可以保证所有进程都获得最大的资源需求，则认为系统是安全的

   * 死锁检测和恢复： 定时检测、进程执行缓慢检测、进程循环等待时检测

     ​					恢复：①抢占资源：从其他进程中抢占资源接触死锁

     ​								② 杀死进程接触死锁③进程回退到某个某个接触死锁的节点

   * 具体策略根据具体的业务选择，数据库系统经常采用死锁检测和进程回退。

------



3. **多线程的好处，只有单核多线程有意义吗？**

* 充分利用cpu的性能、减少cpu的空闲时间，提高并发量
* 加快用户的相应时间
* 不同的任务交付给不同的线程，实现代码模块化、优化简单化
* 单核多线程是通过给不同的进程分发时间片，使其宏观上是并发的

---



3. **线程切换栈会保留哪些？**

 进程是操作系统中资源分配和调度的基本单位，它拥有独立的地址空间和一组资源，所以进程切换时候需要保存的信息比较多

* pcb进程控制块，里面包含进程的虚拟地址空间、进程状态、进程优先级等信息

* cpu寄存器的状态：pc程序计数器、sp栈指针、状态寄存器、通用寄存器
* 进程的上下文，环境变量、堆栈信息、全局变量等
* 内存管理信息：页表

线程是进程的执行单位，同一进程下的线程共享进程的地址空间和资源，但是每个线程有自己的执行栈和局部变量

* 首先是和进程一样，保存cpu的寄存器状态：pc、sp 通用寄存器、状态寄存器
* 线程id、线程 状态等
* 保存线程独自的栈指针，用来保存局部变量
* 如果进程给线程提供了空间来保存信息，这些空间也需要保存下来

---------



4. **线程数为什么要预先定义？**

* 不同的应用场景可能需要的线程数目不同，比如说cpu密集型任务需要的线程数较少，io型线程需要的线程数较多
* 线程的数目并不是越多越好，线程会占用一定的系统资源，比如说内存和cpu时间片，所以具体的线程数目需要在项目执行前就考虑好
* 如果在项目执行的过程中频繁的创建和销毁线程，会浪费大量的成本，极大影响效率，因此我们都是提前规划好线程的数目并且采用线程池，极大提高程序的性能。

---------

5. **操作系统如何接收鼠标的点击事件并转发？**

   os不直接与鼠标交互，鼠标点击后，鼠标驱动向操作系统发送信号，包括点击信息（左右键、位置信息等），操作系统将这个输入信号封装成消息发送给应用程序，应用程序内部循环检测os发送的消息，检测到消息后，查看位置信息，寻找对应的空间，调用其函数

# 网络

1. **http的长连接和短链接**

​		长连接就是基于tcp的通讯中，一致保持连接，不管当前是否发送和接收数据

短链接是只有数据传参数才进行连接，传输完毕即福安比

1. **epoll多路复用如何实现**
2. **如果恶意http请求过多如何处理**
3. **tcp的流量控制**

![image-20240327144641429](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240327144641429.png)

5. **tcp的拥塞控制**

![image-20240327144508507](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240327144508507.png)



6. **http和https的区别，https的加密算法**

   | http                      | https                                        |
   | ------------------------- | -------------------------------------------- |
   | 传输数据明文、不安全      | http和tcp层之间添加 ssl/tsl协议，加密传输    |
   | 端口90                    | 端口443                                      |
   | tcp三次握手后直接http请求 | tcp三次握手后，还需要ssl tsl握手后，加密传输 |
   |                           | 需要申请数字证书，保证服务器可信             |

   

7. **get和post的区别**

   | GET                                   | POST                                                         |
   | ------------------------------------- | ------------------------------------------------------------ |
   | 幂等（对同一url多次操作返回同样结果） | 非幂等                                                       |
   | get请求被浏览器缓存                   | 不会缓存                                                     |
   | 请求放在url中，不安全                 | 数据放在http包体内，安全                                     |
   | 1个tcp文件（header data）返回200 ok   | 2个tcp（header）先发送，100continue，在发送（data）,返回200ok |
   | 获取数据                              | 修改数据                                                     |



5. **输入1个url显示主页的过程**

   >通过dns域名解析器，获得url对应的ip地址
   >
   >通过三次握手建立tcp连接
   >
   >发送http请求
   >
   >服务器返回html结果
   >
   >发送html内的资源请求，获取css等数据
   >
   >四次挥手关闭tcp连接

   >解析html、渲染

5. **tcp和http的关系**

   一个tcp可以发多个http请求，但是同一时间只能处理一个http请求，

   提高效率：1个tcp顺序处理多个http  2 建立多个tcp

6. 什么是SSL、TLS？

   ssl是安全套接字层，在https与tcp之间，用于加密数据，加密和解密的的钥匙不同，为非对称性加密

7. **TSL的四次握手**

   * 客户端向服务器发送加密请求，包括（客户端支持的TSL版本、1个随机数）
   * 服务器确认版本后，返回（服务器的数字证书、另一个随机数）
   * 客户端检查证书，符合的话从证书里取出（加密公钥，后再次发送随机数
   * 服务器收到第三个随机数后，计算出会话密钥，之后通讯用会话密钥加密

6. **tcp和udp的区别**

   | tcp                                     | udp                                                       |
   | --------------------------------------- | --------------------------------------------------------- |
   | 面向连接、可靠                          | 不需要连接、不可靠                                        |
   | 一对一                                  | 一对一 一对多 多对多                                      |
   | 不适用扩充段，是20个字节，头部有消耗    | 8个字节，开销小                                           |
   | 字节流传输，没有边界                    | 按包传送，丢包 乱序                                       |
   | 数据大于mss，在传输层分片，丢片补发该片 | 包大于mtu，会在ip层分片，接收后在ip层组装、再传输给运输层 |
   | 文件传输、http                          | dns、视频音频传输                                         |

   

7. **tcp三次握手、四次挥手**

8. **tcp的粘包和拆包**

   tcp是面向字节流的，没有边界，因此系统在发送tcp时，会通过缓冲区优化

   一次请求发送的数据量过小没达到缓冲区大小，tcp就会将多个请求合并为同一个请求发送

   当一次发送数据超过了缓冲区大小，tcp将其拆分为多个包分多次发送

   解决：

   * 消息定长：发送端将每个包都固定大小，不够可通过补0填充到指定长度
   * 发送端在每个包尾部添加固定的分割符，发生拆包时，等所有包发送完毕后进行合并
   * 消息分为头部和消息体，头部保存整个信息长度，读取到足够长的消息才算完整

# 算法

1. **打印出所有的回文子串**
2. **模拟大数相乘**
3. 判断链表有环
4. 两数之和、三数之和
5. **二分查找、时间复杂度**
6. **topk问题**
7. leetcoe240 搜索二维矩阵

# ios

1. **runtime和runloop**

   runloop负责ios中的事件的监听，每一个线程都对应有一个runloop，main函数自动创建，其余线程需要自己手动打开

   runtime是一套底层的c语言API，负责实现在程序执行的时候动态的调用函数