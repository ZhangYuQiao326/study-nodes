2023 - 3 -13

腾讯客户端实习

![image-20240313153352129](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313153352129.png)

## 语法

**1 const作用**

面向过程： const修饰的常量，放在代码段，定义时必须初始化，且仅本文件可见

面向对象：const成员变量只能通过初始化列表进行初始化，const成员方法在调用const对象时不会修改

传参：const形参可以接收任意实参，且const对象只能调用const方法

**2 static关键字的作用**

面向过程角度

* 修饰==全局变量、函数==，修饰过后，全局变量和函数只能在当前文件可见，是因为在编译生成的符号表中，符号作用域从g（global）变为l（local）
* 修饰==局部变量==，初始化不为0的，放在data段，未初始化和初始化为0，放在bss段
* 局部变量本身不产生符号，通过ebp-偏移量访问，static后，产生local符号

面向对象角度

* 修饰成员变量，变为全局共享，类里面定义，类外初始化
* 修饰成员方法，不再产生this指针，可以通过作用域调用，且static方法只能调用static变量
* static成员方法不能背const 和 virtual修饰，const是因为不调用成员变量，也不会修改，virtual是因为static与类有关，与实例无关，没有多态可言

**3 volatile关键字的作用**

告诉编译器不要对该变量进行优化，因为该变量的值可能会在编译器优化的作用下发生变化，例如多线程环境中，变量可能会被其他线程修改。

在多线程编程中，`volatile`关键字用于确保线程之间对共享变量的可见性。当一个变量被声明为`volatile`时，每次对该变量的读取都会直接从内存中读取，而不是从缓存中读取，同时每次对该变量的写入也会直接写入到内存中，而不是先写入到缓存。这样可以确保当一个线程修改了该变量的值后，其他线程能够立即看到这个修改，而不会因为缓存而导致数据不一致的情况发生。

需要注意的是，`volatile`只能保证可见性，不能保证原子性。如果需要确保多线程环境下对变量的读取和写入是原子操作的，还需要使用其他机制，比如使用`mutex`（互斥锁）或`atomic`类型等。

 

**4 mutable关键字**

mutable作用于==类的成员变量==，即便在const成员函数中，也可以对其进行修改

注意和`const_cast`进行区分，这个作用于const修饰的变量和volatile属性修饰的变量



**5 explict关键字**

作用域==类的构造函数==，修饰的构造函数不能再发生隐式类型转换，必须通过显示构造



**3 c++如何调用c语言？**

c 和 c++在编译过程中的==函数名修饰规则==不同，c是根据==函数名==表示，c++会根据==函数名==和==参数==命名，因此编译c语言需要在`extern "C"{}`之中

同样的原因，c++导致相同函数名，参数不同的函数在==符号表==内的名字不同，这也是==函数重载==的原理



**4 c 和 c++的区别**

1面向对象，使用设计模式      2 引用    3函数重载    4 new和delete   5  异常处理   6 模板  7 STL



**5 const int* p  和 int* cosnt p的区别**

常量指针：const int* p = &a; 即指针的解引用是常量的，即*p不变，但是p = b;

指针常量 int * constp = &a;  指针本身是不变的，解引用可以改变*p = 20;



**6 指针和引用区别**

指针是变量，开辟内存，存指向变量的地址，引用是别名，与变量共享地址

指针可以为空，且可以修改，引用必须初始化，且只能定义一次

引用的本质是指针常量（int* const），是c++的语法糖

指针和引用都可以作为参数传递，减少对变量的拷贝，但是传指针本质上也是值传递，对指针的内容，也就是地址做了拷贝，若在函数内部修改了指针的内容，不会影响函数外部的指针，但是函数内部修改指针指向的位置，即变量，就会修改变量

传引用不存在拷贝，传的就是变量本身



**7 什么时候使用指针传参和引用传参？**

当需要==返回函数内部的通过new出来的局部变量==时候，通过传入指针，保存局部变量的值，但是后续注意释放，内存泄漏

但是也是因为传入指针需要额外开辟空间，对于==对栈内存敏感==的函数（递归）优先使用引用

==类对象的传递==也是使用引用

|              | 只使用传递过来的值，而不对值进行修改 | 需要修改传递过来的值 |
| ------------ | ------------------------------------ | -------------------- |
| 内置数据类型 | 按值传递（小型结构）                 | 指针传递             |
| 数组         | 指针传递                             | 指针传递             |
| 结构         | 指针或引用（较大的结构）             | 指针或引用           |
| 类、对象     | 引用传递                             | 引用传递             |

**8 如何判断大小端存储？**

* 电脑： 小端法

高位存高地址、低位存低地址

* 网络 大端

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314170616566.png" alt="image-20240314170616566" style="zoom: 67%;" />



使用强制类型转换解决

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

```



**9 函数调用栈过程，参数or返回值先入栈？**

1. 保存当前环境的==系统状态==，便于恢复

1. 首先，调用函数时，将调用者==函数的返回地址==压入栈中，以便在函数调用结束后返回到调用者函数的适当位置。
2. 接下来，将调用者函数的==参数==依次压入栈中，通常是从右往左的顺序。
3. 然后，在调用的函数内部执行时，会在栈上分配空间用于==局部变量==、函数内部的==临时变量==以及其他需要的数据。
4. 函数执行结束后，==返回值==会被放入调用者函数期望的位置（通常是寄存器或者内存），然后函数返回到调用者函数处，将栈上的数据恢复到调用前的状态，包括返回地址和参数等。

因此，在函数调用过程中，参数变量会先于返回值入栈。这是因为参数需要在函数内部使用，而返回值通常是在函数执行结束后才需要。



**10 static_cast为什么安全？**

1. 在不引入额外开销的情况下进行类型转换
2. 显示的注明类型转换，避免隐式类型转换造成的问题
3. 保持了const的属性，转换前后的const属性不变



## 类

**1 c++的this指针是干什么用的？**

this实际上是成员函数的一个形参，在调用成员函数时候，会将对象的地址作为实参传递给this，

this是局部形参，只能用在成员函数的内部，只有调用成员函数时才给this传值



**2 什么情况下发生拷贝构造？**

* 用一个实例化对象去初始化另一个对象
* 通过值传递方式传入对象
* ==vs==下值传递方式返回一个对象， g++下不会调用拷贝构造

**1 继承的赋值兼容规则**？

派生类对象可以赋值给基类对象、基类对象指针、基类对象引用，这个过程中会发生切片

反过来，若是基类对象想赋值给派生类对象指针，则需要通过dynamic_cast进行判断，若基类指针是指向派生类的对象，则可以赋值成功，否则失败



**2 派生类的构造函数和析构函数是怎么样的？**

* 派生类对象必须调用基类的==构造方法==初始化基类的成员变量，若基类没有默认的构造函数，则必须在派生类的初始化列表中显示调用
* 派生类对象必须调用基类的==拷贝构造==和==运算符重载==给基类的成员变量赋值
* 派生类的==析构函数==会在执行完毕后自动调用基类的析构函数

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313164545853.png" alt="image-20240313164545853" style="zoom:33%;" />

* 当派生类和基类由同名的成员方法时，派生类会隐藏掉基类的方法和变量，可以通过基类的作用域调用



**3 继承和组合区别是什么？**

两种都是类的复用技术

继承允许根据基类的实现来定义派生类，基类的内部对派生类可见，耦合度很高，两个类有关系则优先使用，实现多态也要使用

==组合==是将基类封装在另一个类的内部，基类的内部对其不可见，耦合度很低，代码维护性好



**4 继承的好处是什么？**

* 实现了代码复用
* 可以通过继承，在基类的内部给所有派生类保留同一的纯虚函数接口，派生类进行重写，可以实现多态，即通过基类指针访问不同派生类对象的同名覆盖方法





## 内存管理

**1 new和delete，什么时候用new[]申请的内存，可以用delete释放**？

new的作用是 申请开辟内存空间 +申请失败抛异常 +  调用对象的构造函数

operator new  是 malloc + 申请内存失败抛异常

 malloc： 申请失败return 0 

delete： 释放内存空间 + 调用对象的析构函数

operatpr delete 和 free 区别不大

== 对于自定义类型，如果提供了析构函数，当使用new[]申请空间时，除了申请对象外，额外申请4个字节记录对象的申请个数，必须调用delelte[]释放==

其余情况下，使用new[]申请，可以用delete ptr释放

**2 虚拟地址空间**

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313161217327.png" alt="image-20240313161217327" style="zoom:67%;" />





.bss： 未初始化、初始化为0的==全局变量==，未初始化、初始化为0的==静态变量==

* 不在可执行未见中，由系统初始化，初始化时，部分bss段清0

.data ：初始化不为0的==全局变量==和==静态变量==

.text : 存放程序执行代码、只读==常量==、==字符串常量==、==类的成员函数==，==静态成员变量、静态成员函数==

* data text在可执行文件中，系统从可执行文件中加载

```cpp
int bss_1;// 未初始化的全局变量，bss段
int bss_2 = 0;// 初始化为0的全局变量，bss段
int data_1 = 1;// 初始化非0的全局变量，data段
int main() {
    static int bss_3;// 未初始化的静态局部变量，bss段
    static int bss_4 = 0;// 初始化为0静态局部变量，bss段
    static int data_2 = 1;// 初始化非0静态局部变量，data段
}
```



**3 如何防止内存泄漏**

内存泄漏不是指物理内存上的泄漏，而是指不适用的内存没有释放，导致对其的控制

常见的两种

* 堆内存泄漏：指用户通过new malloc operator new等申请的内存资源使用完毕后，没有用delelte free释放，，导致无法使用
* 在多态中，基类析构函数没有声明为虚函数，导致派生类调用析构时没有调用到基类析构，导致基类成员变量没有被释放
* 系统资源泄漏：套接字、文件描述符等使用韩币后没有释放

对长期运行的程序危害比较大，比如操作系统、后台服务等

linux下的内存检测工具：valgrind

windows下常见的工具有 CRT



**4 什么时候出现访问越界？**

越界即系统给你分配了固定的内存，你访问到了外部的内存即越界

* 访问数组、vector会越界
* 字符串处理没有带0，会越界
* 在dynamic_cast中，派生类指针指向基类对象失败，解引用会越界



**开辟内存方式**

1. `malloc`（Memory Allocation）：
   - 函数签名：`void* malloc(size_t size);`
   - 作用：用于分配指定大小的堆内存，返回一个指向分配内存的指针。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

2. `calloc`（Contiguous Allocation）：
   - 函数签名：`void* calloc(size_t num_elements, size_t element_size);`
   - 作用：用于分配指定数量和大小的连续块内存，返回一个指向分配内存的指针。所有分配的内存都被初始化为零。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

3. `realloc`（Reallocate Memory）：
   - 函数签名：`void* realloc(void* ptr, size_t new_size);`
   - 作用：用于重新调整先前分配的内存块的大小。通常用于扩展或缩小内存块。它接受一个先前分配的内存块指针和新的大小作为参数，返回一个指向重新分配内存的指针。如果分配失败，返回`NULL`。如果`ptr`为`NULL`，则`realloc`的行为等同于`malloc`。

## STL

**1 讲一下空间配置器**

空间配置器主要是给容器使用的

* 一是把内存开辟和对象构造分开，把内存释放和对象析构分开，因为有一些场景下是需要先开辟空间，在后续执行过程中在创建对象，在析构对象后，也不需要释放内存空间
* 二是解决==频繁向系统申请小块内存==的问题，容易造成资源泄露
* 原理：配置器有两级构成，以128字节为界限将内存块分为大内存和小内存，大内存块的申请释放由一级配置器进行管理，对mallo和free与申请失败抛异常进行封装，和operator new差不多
* 二级配置器用来管理小内存，底层是一个哈希桶，内存申请的大小是从8字节到128字节
* 为什么是8个字节，因为下方挂的是内存块，为表示64位下的地址空间，采用8字节



**2 vector和list的区别**

vector支持随机访问，优先级队列就是基于vector构建的适配器

list支持高效的增删改查

## 数据结构

![image-20240313180924748](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313180924748.png)



## c++11

**1 智能指针**



**2 初始化列表**

功能：可以通过初始化列表指定成员变量的初始化方式，在类中，成员变量的初始化顺序与其声明的顺序一致，与初始化列表内的顺序无关

底层：`myvector(std::initializer_list<T> il)`,std指定初始化列表容器，用来接收值

`std::initializer_list ilt = { 10, 20, 30 }`





# 操作系统

**1 进程PCB和状态**

操作系统对进程进行管理，实际上是将进程控制块PCB放入链表中，进行增删改查

```cpp
struct task_struct{
    // pid
    // PRI NI 优先级
    // task_state_array  进程状态
    // mm_struct  进程地址空间
}
```

进程状态的本质：进程的pcb放入不同的队列

* 执行态：pcb放入cpu管理的任务执行队列中，放入即为执行态
* 阻塞态：进程需要外设资源，没有即阻塞，将pcb从执行队列放入外设管理的wait等待队列
* 挂起态：进程在阻塞态的时候，仍浪费内存，os将其置换到磁盘之中

linux下通过结构体进行管理

![image-20240320144553504](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320144553504.png)



**1 进程调度算法**

--用于处理cpu管理的任务执行队列中的待执行进程的先后顺序调度

1. 先来先服务，利于长作业进程，短作业可能会饿死
2. 短作业优先，不利于长作业
3. 最短剩余时间悠闲，比较进程还需要多少时间片，最短的执行
4. 优先级调度，linux中的优先级通过PCB中的PRI(priority) 和 NI(nice) 控制，用户可以设置NI的值来改变优先级，范围【-20，19】
5. 时间片轮转，过长不利于进程的实时性，过短造成大量上下文切换，浪费性能
6. 多级反馈队列，优先级与时间片的结合，进程没有执行完则放入下一个队列，每一个队列有优先级，第一层最高，每个队列内按时间片轮转控制

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320165427807.png" alt="image-20240320165427807" style="zoom: 50%;" />

**2 进程地址空间**

进程地址空间是进程PCB中的一个变量

通过mm_struct结构体进行管理

【为什么需要进程地址空间？】

1. 若进程直接访问物理内存，可能会发生越界访问，不安全
2. 地址空间的存在，可以更方便的进行进程与进程之间的数据代码解耦，保证进程之间的独立性
3. 编译器也会按照进程地址空间的规则对代码进行编译
4. cpu读取的指令的地址都是虚拟地址

![image-20240320173630091](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320173630091.png)





# 面试

2024-4-7 qq浏览器客户端1面

1. tcp 和 udp区别

2. tcp如何保证其可靠性，比如说传输的包有序、是否丢失 （答了三握四挥，含有seq和ack，分片传输，丢失补发，拥塞控制、流量控制。。。知道的都说了）

3. tcp片丢失如何补发的？（自己挖坑自己跳，不会。。。）

4. 说一下拥塞控制、流量控制 （又挖坑了。。。还好提前复习了）

5. 如何保证http连接过程中断开了，重连后还能恢复到之前的位置

   比如：下载文件，网络断开，恢复后仍能继续下载而不是重新下载

   （瞎答了tcp连接时，客户端断开，服务器不发消息则不知道断开，把面试官整笑了）

   提示： http头中有字段来记录位置

6. 说一下虚拟内存和物理内存 （只说了进程地址空间。。。）

7. 虚拟内存的好处是什么？（扩充内存、进程安全、还不够。。。。。）

8. 进程地址空间各个段存放什么数据？

9. 进程通信。。。（说了信号量、管道等，还不够，忘了，说了解线程通信）

10. 进程和线程区别，为什么需要线程，好处是什么？（不知道，举了qq的例子。。。最终目的说了为了提高效率。。。）

11. 线程死锁、解决方式，着重问了”有序分配资源“，进程有序还是资源有序，都可

12. 数据库事务相关，场景：多线程访问数据库脏数据，  （完全不会。。。 用锁保证安全）

13. 场景：1亿条访问记录存磁盘，问如何找到访问最多topk个

    。。。。红黑树？  内存不够，无法加入树

    。。。。位图？  什么是位图？

    。。。。快排+topk？     。。。内存不够怎么快排

    答案： 将1亿条数据分块放入内存，分块进行哈希统计次数，通过topk查找最多k条记录

11 算法题： 有序的链表，删除重复的元素 1 2 33 4  ->  124

12 反问： 岗位对c++功底要求？ 答：岗位用c++和前端技术

​				  为什么面试不问c++？ 答：面试的简历可能有java、c++等，对语言不看重，后期快速学习，着重考察基本功

​				  对我不足建议？ 答：os、db、网络系统复习学习
