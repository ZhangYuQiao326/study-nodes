2023 - 3 -13

腾讯客户端实习

![image-20240313153352129](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313153352129.png)

## 语法

**1 const作用**

面向过程： const修饰的常量，放在代码段，定义时必须初始化，且仅本文件可见

面向对象：const成员变量只能通过初始化列表进行初始化，const成员方法在调用const对象时不会修改

传参：const形参可以接收任意实参，且const对象只能调用const方法

**2 static关键字的作用**

面向过程角度

* 修饰==全局变量、函数==，修饰过后，全局变量和函数只能在当前文件可见，是因为在编译生成的符号表中，符号作用域从g（global）变为l（local）
* 修饰==局部变量==，初始化不为0的，放在data段，未初始化和初始化为0，放在bss段
* 局部变量本身不产生符号，通过ebp-偏移量访问，static后，产生local符号

面向对象角度

* 修饰成员变量，变为全局共享，类里面定义，类外初始化
* 修饰成员方法，不再产生this指针，可以通过作用域调用，且static方法只能调用static变量
* static成员方法不能背const 和 virtual修饰，const是因为不调用成员变量，也不会修改，virtual是因为static与类有关，与实例无关，没有多态可言

**3 volatile关键字的作用**

告诉编译器不要对该变量进行优化，因为该变量的值可能会在编译器优化的作用下发生变化，例如多线程环境中，变量可能会被其他线程修改。

在多线程编程中，`volatile`关键字用于确保线程之间对共享变量的可见性。当一个变量被声明为`volatile`时，每次对该变量的读取都会直接从内存中读取，而不是从缓存中读取，同时每次对该变量的写入也会直接写入到内存中，而不是先写入到缓存。这样可以确保当一个线程修改了该变量的值后，其他线程能够立即看到这个修改，而不会因为缓存而导致数据不一致的情况发生。

需要注意的是，`volatile`只能保证可见性，不能保证原子性。如果需要确保多线程环境下对变量的读取和写入是原子操作的，还需要使用其他机制，比如使用`mutex`（互斥锁）或`atomic`类型等。

 

**4 mutable关键字**

mutable作用于==类的成员变量==，即便在const成员函数中，也可以对其进行修改

注意和`const_cast`进行区分，这个作用于const修饰的变量和volatile属性修饰的变量



**5 explict关键字**

作用域==类的构造函数==，修饰的构造函数不能再发生隐式类型转换，必须通过显示构造



**3 c++如何调用c语言？**

c 和 c++在编译过程中的==函数名修饰规则==不同，c是根据==函数名==表示，c++会根据==函数名==和==参数==命名，因此编译c语言需要在`extern "C"{}`之中

同样的原因，c++导致相同函数名，参数不同的函数在==符号表==内的名字不同，这也是==函数重载==的原理



**4 c 和 c++的区别**

1面向对象，使用设计模式      2 引用    3函数重载    4 new和delete   5  异常处理   6 模板  7 STL



**5 const int* p  和 int* cosnt p的区别**

常量指针：const int* p = &a; 即指针的解引用是常量的，即*p不变，但是p = b;

指针常量 int * constp = &a;  指针本身是不变的，解引用可以改变*p = 20;



**6 指针和引用区别**

指针是变量，开辟内存，存指向变量的地址，引用是别名，与变量共享地址

指针可以为空，且可以修改，引用必须初始化，且只能定义一次

引用的本质是指针常量（int* const），是c++的语法糖

指针和引用都可以作为参数传递，减少对变量的拷贝，但是传指针本质上也是值传递，对指针的内容，也就是地址做了拷贝，若在函数内部修改了指针的内容，不会影响函数外部的指针，但是函数内部修改指针指向的位置，即变量，就会修改变量

传引用不存在拷贝，传的就是变量本身



**7 什么时候使用指针传参和引用传参？**

当需要==返回函数内部的通过new出来的局部变量==时候，通过传入指针，保存局部变量的值，但是后续注意释放，内存泄漏

但是也是因为传入指针需要额外开辟空间，对于==对栈内存敏感==的函数（递归）优先使用引用

==类对象的传递==也是使用引用

|              | 只使用传递过来的值，而不对值进行修改 | 需要修改传递过来的值 |
| ------------ | ------------------------------------ | -------------------- |
| 内置数据类型 | 按值传递（小型结构）                 | 指针传递             |
| 数组         | 指针传递                             | 指针传递             |
| 结构         | 指针或引用（较大的结构）             | 指针或引用           |
| 类、对象     | 引用传递                             | 引用传递             |

**8 如何判断大小端存储？**

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314170616566.png" alt="image-20240314170616566" style="zoom: 67%;" />



使用强制类型转换解决

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

```



**9 函数调用栈过程，参数or返回值先入栈？**

1. 保存当前环境的==系统状态==，便于恢复

1. 首先，调用函数时，将调用者==函数的返回地址==压入栈中，以便在函数调用结束后返回到调用者函数的适当位置。
2. 接下来，将调用者函数的==参数==依次压入栈中，通常是从右往左的顺序。
3. 然后，在调用的函数内部执行时，会在栈上分配空间用于==局部变量==、函数内部的==临时变量==以及其他需要的数据。
4. 函数执行结束后，==返回值==会被放入调用者函数期望的位置（通常是寄存器或者内存），然后函数返回到调用者函数处，将栈上的数据恢复到调用前的状态，包括返回地址和参数等。

因此，在函数调用过程中，参数变量会先于返回值入栈。这是因为参数需要在函数内部使用，而返回值通常是在函数执行结束后才需要。



**10 static_cast为什么安全？**

1. 在不引入额外开销的情况下进行类型转换
2. 显示的注明类型转换，避免隐式类型转换造成的问题
3. 保持了const的属性，转换前后的const属性不变



## 类

**1 c++的this指针是干什么用的？**

this实际上是成员函数的一个形参，在调用成员函数时候，会将对象的地址作为实参传递给this，

this是局部形参，只能用在成员函数的内部，只有调用成员函数时才给this传值



**2 什么情况下发生拷贝构造？**

* 用一个实例化对象去初始化另一个对象
* 通过值传递方式传入对象
* ==vs==下值传递方式返回一个对象， g++下不会调用拷贝构造

**1 继承的赋值兼容规则**？

派生类对象可以赋值给基类对象、基类对象指针、基类对象引用，这个过程中会发生切片

反过来，若是基类对象想赋值给派生类对象指针，则需要通过dynamic_cast进行判断，若基类指针是指向派生类的对象，则可以赋值成功，否则失败



**2 派生类的构造函数和析构函数是怎么样的？**

* 派生类对象必须调用基类的==构造方法==初始化基类的成员变量，若基类没有默认的构造函数，则必须在派生类的初始化列表中显示调用
* 派生类对象必须调用基类的==拷贝构造==和==运算符重载==给基类的成员变量赋值
* 派生类的==析构函数==会在执行完毕后自动调用基类的析构函数

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313164545853.png" alt="image-20240313164545853" style="zoom:33%;" />

* 当派生类和基类由同名的成员方法时，派生类会隐藏掉基类的方法和变量，可以通过基类的作用域调用



**3 继承和组合区别是什么？**

两种都是类的复用技术

继承允许根据基类的实现来定义派生类，基类的内部对派生类可见，耦合度很高，两个类有关系则优先使用，实现多态也要使用

==组合==是将基类封装在另一个类的内部，基类的内部对其不可见，耦合度很低，代码维护性好



**4 继承的好处是什么？**

* 实现了代码复用
* 可以通过继承，在基类的内部给所有派生类保留同一的纯虚函数接口，派生类进行重写，可以实现多态，即通过基类指针访问不同派生类对象的同名覆盖方法



**5 说一说多态**

c++中的多态分为静多态和动多态

* 静多态是==编译==时期的多态，技术有==函数重载==、==模板==等
* 动多态是==程序执行==过程中的多态，即通过基类指针访问派生类对象的同名覆盖方法
* 多态与实例化的对象有关，跟调用对象的类型无关，基类和派生类都是通过基类指针或引用来调用虚函数



**6 构成多态的条件**

1 基类中必须通过virtual提供==虚函数的统一接口==，派生类对象对纯虚函数进行重写

2 必须通过==基类指针==或引用调用派生类重写的虚函数



【关于虚函数】https://csguide.cn/cpp/object_oriented/why_template_cannot_be_virtual.html#%E9%97%AE%E9%A2%98%E5%90%AB%E4%B9%89

## 内存管理

**1 new和delete，什么时候用new[]申请的内存，可以用delete释放**？

new的作用是 申请开辟内存空间 +申请失败抛异常 +  调用对象的构造函数

operator new  是 malloc + 申请内存失败抛异常

 malloc： 申请失败return 0 

delete： 释放内存空间 + 调用对象的析构函数

operatpr delete 和 free 区别不大

== 对于自定义类型，如果提供了析构函数，当使用new[]申请空间时，除了申请对象外，额外申请4个字节记录对象的申请个数，必须调用delelte[]释放==

其余情况下，使用new[]申请，可以用delete ptr释放



**2 虚拟地址空间**

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313161217327.png" alt="image-20240313161217327" style="zoom:67%;" />





.bss： 未初始化、初始化为0的==全局变量==，未初始化、初始化为0的==静态变量==

* 不在可执行未见中，由系统初始化，初始化时，部分bss段清0

.data ：初始化不为0的==全局变量==和==静态变量==

.text : 存放程序执行代码、只读==常量==、==字符串常量==、==类的成员函数==，==静态成员变量、静态成员函数==

* data text在可执行文件中，系统从可执行文件中加载

```cpp
int bss_1;// 未初始化的全局变量，bss段
int bss_2 = 0;// 初始化为0的全局变量，bss段
int data_1 = 1;// 初始化非0的全局变量，data段
int main() {
    static int bss_3;// 未初始化的静态局部变量，bss段
    static int bss_4 = 0;// 初始化为0静态局部变量，bss段
    static int data_2 = 1;// 初始化非0静态局部变量，data段
}
```



**3 如何防止内存泄漏**

内存泄漏不是指物理内存上的泄漏，而是指不适用的内存没有释放，导致对其的控制

常见的两种

* 堆内存泄漏：指用户通过new malloc operator new等申请的内存资源使用完毕后，没有用delelte free释放，，导致无法使用
* 在多态中，基类析构函数没有声明为虚函数，导致派生类调用析构时没有调用到基类析构，导致基类成员变量没有被释放
* 系统资源泄漏：套接字、文件描述符等使用韩币后没有释放

对长期运行的程序危害比较大，比如操作系统、后台服务等

linux下的内存检测工具：valgrind

windows下常见的工具有 CRT



**4 什么时候出现访问越界？**

越界即系统给你分配了固定的内存，你访问到了外部的内存即越界

* 访问数组、vector会越界
* 字符串处理没有带0，会越界
* 在dynamic_cast中，派生类指针指向基类对象失败，解引用会越界



**开辟内存方式**

1. `malloc`（Memory Allocation）：
   - 函数签名：`void* malloc(size_t size);`
   - 作用：用于分配指定大小的堆内存，返回一个指向分配内存的指针。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

2. `calloc`（Contiguous Allocation）：
   - 函数签名：`void* calloc(size_t num_elements, size_t element_size);`
   - 作用：用于分配指定数量和大小的连续块内存，返回一个指向分配内存的指针。所有分配的内存都被初始化为零。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

3. `realloc`（Reallocate Memory）：
   - 函数签名：`void* realloc(void* ptr, size_t new_size);`
   - 作用：用于重新调整先前分配的内存块的大小。通常用于扩展或缩小内存块。它接受一个先前分配的内存块指针和新的大小作为参数，返回一个指向重新分配内存的指针。如果分配失败，返回`NULL`。如果`ptr`为`NULL`，则`realloc`的行为等同于`malloc`。

## STL

**1 讲一下空间配置器**

空间配置器主要是给容器使用的

* 一是把内存开辟和对象构造分开，把内存释放和对象析构分开，因为有一些场景下是需要先开辟空间，在后续执行过程中在创建对象，在析构对象后，也不需要释放内存空间
* 二是解决==频繁向系统申请小块内存==的问题，容易造成资源泄露
* 原理：配置器有两级构成，以128字节为界限将内存块分为大内存和小内存，大内存块的申请释放由一级配置器进行管理，对mallo和free与申请失败抛异常进行封装，和operator new差不多
* 二级配置器用来管理小内存，底层是一个哈希桶，内存申请的大小是从8字节到128字节
* 为什么是8个字节，因为下方挂的是内存块，为表示64位下的地址空间，采用8字节



**2 vector和list的区别**

vector支持随机访问，优先级队列就是基于vector构建的适配器

list支持高效的增删改查

## 数据结构

![image-20240313180924748](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313180924748.png)



## c++11

**1 智能指针**



**2 初始化列表**

功能：可以通过初始化列表指定成员变量的初始化方式，在类中，成员变量的初始化顺序与其声明的顺序一致，与初始化列表内的顺序无关

底层：`myvector(std::initializer_list<T> il)`,std指定初始化列表容器，用来接收值

`std::initializer_list ilt = { 10, 20, 30 }`





# 网络

## TCP

* 运行在计算机上的进程通过端口号来区分，16bit标识，0~ 65535

  | 类型 | UDP                              | TCP                    |
  | ---- | -------------------------------- | ---------------------- |
  |      | 支持一对一，一对多               | 一对一                 |
  |      | 面向报文                         | 面向字节流             |
  |      | 无连接                           | 面向链接               |
  |      | 不安全                           | 安全                   |
  |      | 向上层提供无连接、不可靠传输服务 | 面向连接的可靠传输服务 |
  |      | 视频、会议等实时                 | 文件传输               |

  

![image-20240314183205222](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314183205222.png)



![image-20240314192809279](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314192809279.png)



















